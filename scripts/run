#!/bin/bash

# Generates slurm batch scripts for running
# strong/weak scaling benchmarks on a cluster,
# and gnuplot scripts for result plotting.
#
# Author: Hoby Rakotoarivelo

# Run params
CLUSTER=""
SUPPORTED_CLUSTERS=( "darwin" )
SCALING_RUNS=( "strong" )
NODES=1
RANKS=""
CORES=1
THREADS=""
EXTENT=0
MAX_NODES=1
MAX_THREADS=1
RANKS_PER_NODE=1
THREADS_PER_CORE=1
REVERSE_RANKS="n"
PARTITION="scaling"
HYPERTHREADING=false
OPENMP_ONLY=false
WEAK_SCALE_ONLY=""
THREAD_FLAG="n"
COMPILER="intel"
CXX_VERSION=0.0.0
CPU_AFFINITY=""
MODE=""
USER=""

# Version numbers
MPI_VERSION=2.1.5
BOOST_VERSION=1.68.0
SOURCE_DIR="$(pwd)/.."
DATA_DIR="../test_data"
BUILD_DIR=""

# Remap params
APP=""
MPI_ARGS=""
DIMENSION=0
SOURCE_SIZE=0
SOURCE_MAX=0
TARGET_SIZE=0
TARGET_MAX=0
ENTITY_KIND=""
FIELD=""
MATER_FIELD=""
SOURCE_FILE=""
TARGET_FILE=""
MATER_FILE=""
IS_CONVEX=""
IS_CONFORMAL=""
REMAP_ORDER=0
FIELD_ORDER=0
RESULT_FILE=""

# Note:
# -e: fail if some command exits with non zero status
# -u: treat undefined variables as error
# -o pipefail: pipe ok if all involved commands are ok
set -e             
set -u
set -o pipefail

print_usage() {

  # options formatting
  _CHOICE="\e[32m<choice>\e[0m"
  _STRING="\e[32m<string>\e[0m"
  _PATH="\e[32m<path>\e[0m"
  _INT="\e[32m<int>\e[0m"
  _INT_PATH="\e[32m<int|path>\e[0m"

  echo -e "Usage: \e[32m./run [options]\e[0m"
  echo -e "Options:"
  echo -e "  -h, --help                    show this help message and exit"
  echo -e "  -a, --app $_CHOICE            current app [core|t-junction|multimat]"
  echo -e "  -g, --cluster $_CHOICE        current cluster [darwin]"
  echo -e "  -b, --build                   rebuild the app"
  echo -e "  -n, --nodes $_INT             number of nodes"     
  echo -e "  -r, --ranks $_INT             ranks per node"    
  echo -e "  -p, --partition $_STRING      slurm partition"    
  echo -e "  -u, --user $_STRING           slurm user"    
  echo -e "  -c, --compiler $_CHOICE       compiler [intel|gcc]"    
  echo -e "  -w, --hwthreads               enable hyperthreading"    
  echo -e "  -d, --dim $_INT               mesh dimension [2|3]"    
  echo -e "  -f, --field $_STRING          mesh field to remap"    
  echo -e "  -q, --field-order $_INT       field order"    
  echo -e "  -s, --source $_INT_PATH       source mesh size or file"    
  echo -e "  -t, --target $_INT_PATH       target mesh size or file"    
  echo -e "  -m, --material-field $_STRING material field function"    
  echo -e "  -z, --material-file $_PATH    material field file"    
  echo -e "  -k, --entity $_CHOICE         remap entity kind [cell|node]"    
  echo -e "  -o, --order $_INT             interpolation order"    
  echo -e "  -i, --conform                 conformal meshes"   
  echo -e "  -x, --convex                  convex polygons"   
  echo -e "  -y, --thread-only             thread scaling only"
  echo -e "  -e, --results $_PATH          results output file"
  exit 1
}

print_params() {
  echo -e "Run params for \e[32m${APP}\e[0m app:"
  echo -e "- nodes: \e[32m${MAX_NODES}\e[0m"
  echo -e "- cluster: \e[32m${CLUSTER}\e[0m"
  echo -e "- partition: \e[32m${PARTITION}\e[0m"
  echo -e "- slurm user: \e[32m${USER}\e[0m"
  echo -e "- cores_per_node: \e[32m${CORES}\e[0m"
  echo -e "- ranks_per_node: \e[32m${RANKS_PER_NODE}\e[0m"
  echo -e "- threads_per_rank: \e[32m${MAX_THREADS}\e[0m"
  echo -e "- hyperthreading: \e[32m${HYPERTHREADING}\e[0m"
  echo -e "- compiler: \e[32m${COMPILER}\e[0m"

  case "${APP}" in
    t-junction)
      echo -e "- dimension: \e[32m${DIMENSION}\e[0m"
      echo -e "- source_cells: \e[32m${SOURCE_MAX}\e[0m"
      echo -e "- target_cells: \e[32m${TARGET_MAX}\e[0m"
      echo -e "- conformal: \e[32m${IS_CONFORMAL}\e[0m"
      echo -e "- material_field: \e[32m${MATER_FIELD}\e[0m"
      echo -e "- entity_kind: \e[32m${ENTITY_KIND}\e[0m"
      echo -e "- interpolation order: \e[32m${REMAP_ORDER}\e[0m";;
    multimat)
      echo -e "- dimension: \e[32m${DIMENSION}\e[0m"
      echo -e "- source_file: \e[32m${SOURCE_FILE}\e[0m"
      echo -e "- target_file: \e[32m${TARGET_FILE}\e[0m"
      echo -e "- material_field: \e[32m${MATER_FIELD}\e[0m"
      echo -e "- material_file: \e[32m${MATER_FILE}\e[0m"
      echo -e "- convex: \e[32m${IS_CONVEX}\e[0m"
      echo -e "- entity_kind: \e[32m${ENTITY_KIND}\e[0m"
      echo -e "- interpolation order: \e[32m${REMAP_ORDER}\e[0m"
      echo -e "- results_file: \e[32m${RESULT_FILE}\e[0m";;
    timing)
      echo -e "- dimension: \e[32m${DIMENSION}\e[0m"
      echo -e "- source_cells: \e[32m${SOURCE_MAX}\e[0m"
      echo -e "- target_cells: \e[32m${TARGET_MAX}\e[0m"
      echo -e "- conformal: \e[32m${IS_CONFORMAL}\e[0m"
      echo -e "- reverse_ranks: \e[32m${REVERSE_RANKS}\e[0m"
      echo -e "- weak_scale: \e[32m${WEAK_SCALE_ONLY}\e[0m"
      echo -e "- entity_kind: \e[32m${ENTITY_KIND}\e[0m"
      echo -e "- interpolation order: \e[32m${REMAP_ORDER}\e[0m"
      echo -e "- field order: \e[32m${FIELD_ORDER}\e[0m";;
    (*)
      echo -e "- dimension: \e[32m${DIMENSION}\e[0m"
      [ "${SOURCE_FILE}" != "" ] && \
        echo -e "- source_file: \e[32m${SOURCE_FILE}\e[0m" || \
        echo -e "- source_cells: \e[32m${SOURCE_MAX}\e[0m"
      [ "${TARGET_FILE}" != "" ] && \
        echo -e "- target_file: \e[32m${TARGET_FILE}\e[0m" || \
        echo -e "- target_cells: \e[32m${TARGET_MAX}\e[0m"
      echo -e "- field: \e[32m${FIELD}\e[0m"
      echo -e "- convex: \e[32m${IS_CONVEX}\e[0m"
      echo -e "- conformal: \e[32m${IS_CONFORMAL}\e[0m"
      echo -e "- material_field: \e[32m${MATER_FIELD}\e[0m"
      echo -e "- entity_kind: \e[32m${ENTITY_KIND}\e[0m"
      echo -e "- interpolation order: \e[32m${REMAP_ORDER}\e[0m"
      echo -e "- results_file: \e[32m${RESULT_FILE}\e[0m";;
  esac
}

check_params() {

  # invalid cluster
  if [ $(echo "${SUPPORTED_CLUSTERS}" | grep -c -w "${CLUSTER}") -ne 1 ]; then
    echo -e "\e[31mError: unsupported cluster '${CLUSTER}'\e[0m"
    exit 1
  # invalid number of nodes
  elif [[ ! "${MAX_NODES}" =~ ^[0-9]+$ ]] || (( ${MAX_NODES} < 1 )); then
    echo -e "\e[31mError: invalid number of nodes\e[0m"
    exit 1
  # no support for distributed multimat
  elif [ "${APP}" = "multimat" ] && (( ${MAX_NODES} > 1 )); then
    echo -e "\e[31mSorry, distributed multimat is not yet supported\e[0m"
    exit 1
  # invalid rank per node
  elif [[ ! "${RANKS_PER_NODE}" =~ ^[0-9]+$ ]] \
       || (( ${RANKS_PER_NODE} < 1 )) || (( ${RANKS_PER_NODE} > ${CORES})); then
    echo -e "\e[31mError: invalid rank per node\e[0m"
    exit 1
  # unsupported compiler
  elif [ "${COMPILER}" != "intel" ] && [ "${COMPILER}" != "gcc" ]; then
    echo -e "\e[31mError: unsupported compiler '${COMPILER}'\e[0m"
    exit 1
  # invalid mesh dimension
  elif [[ ! "${DIMENSION}" =~ ^[2-3]$ ]]; then 
    echo -e "\e[31mError: invalid mesh dimension [2|3]\e[0m"
    exit 1
  # neither a source exodus file nor a source cells extent supplied
  elif [ ! -f ${SOURCE_FILE} ] && { [[ ! "${SOURCE_MAX}" =~ ^[0-9]+$ ]] || (( ${SOURCE_MAX} < 1)); }; then
    echo -e "\e[31mError: invalid source file or cells count\e[0m"
    exit 1 
  # neither a target exodus file nor a target cells extent supplied
  elif [ ! -f ${TARGET_FILE} ] && { [[ ! "${TARGET_MAX}" =~ ^[0-9]+$ ]] || (( ${TARGET_MAX} < 1)); }; then
    echo -e "\e[31mError: invalid target file or cells count\e[0m"
    exit 1
  # mandatory source file
  elif { [ ${SOURCE_MAX} -eq 0 ] || [ "${APP}" = "multimat" ]; } && [ ! -f ${SOURCE_FILE} ]; then
    echo -e "\e[31mError: invalid source file '${SOURCE_FILE}'\e[0m"
    exit 1
  # mandatory target file
  elif { [ ${TARGET_MAX} -eq 0 ] || [ "${APP}" = "multimat" ]; } && [ ! -f ${TARGET_FILE} ]; then
    echo -e "\e[31mError: invalid target file '${TARGET_FILE}'\e[0m"
    exit 1
  # unknown entity kind
  elif [ "${ENTITY_KIND}" != "cell" ] && [ "${ENTITY_KIND}" != "node" ]; then
    echo -e "\e[31mError: invalid '${ENTITY_KIND}' entity kind\e[0m"
    exit 1
  # invalid interpolation order
  elif [[ ! "${REMAP_ORDER}" =~ ^[1-2]$ ]]; then
    echo -e "\e[31mError: invalid remap order [1-2]\e[0m"
    exit 1 
  # invalid field order
  elif [[ ! "${FIELD_ORDER}" =~ ^[0-2]$ ]]; then
    echo -e "\e[31mError: invalid field order [0-2]\e[0m"
    exit 1 
  fi

  # print params eventually
  print_params  
}

set_default_params() {

  [ "${CLUSTER}" != "" ] || CLUSTER="${SUPPORTED_CLUSTER[0]}"

  case "${APP}" in
    core)
      [ "${DIMENSION}" -eq 0 ] && DIMENSION=3
      [ "${SOURCE_MAX}" -eq 0 ] && SOURCE_MAX=40
      [ "${TARGET_MAX}" -eq 0 ] && TARGET_MAX=120
      [ "${IS_CONFORMAL}" != "" ] || IS_CONFORMAL="y"
      [ "${FIELD}" != "" ] || FIELD="73.98"
      [ "${ENTITY_KIND}" != "" ] || ENTITY_KIND="cell"
      [ "${REMAP_ORDER}" -eq 0 ] && REMAP_ORDER=1
      [ "${RESULT_FILE}" != "" ] || RESULT_FILE="jali_rect_3d_cell_f0_r1.txt";;
    t-junction)
      [ "${DIMENSION}" -eq 0 ] && DIMENSION=3
      [ "${SOURCE_MAX}" -eq 0 ] && SOURCE_MAX=40
      [ "${TARGET_MAX}" -eq 0 ] && TARGET_MAX=120
      [ "${ENTITY_KIND}" != "" ] || ENTITY_KIND="cell"
      [ "${IS_CONFORMAL}" != "" ] || IS_CONFORMAL="y"
      [ "${IS_CONVEX}" != "" ] || IS_CONVEX="y"
      [ "${MATER_FIELD}" != "" ] || MATER_FIELD="'x','y','z'"
      [ "${REMAP_ORDER}" -eq 0 ] && REMAP_ORDER="2";;
    multimat)
      [ "${DIMENSION}" -eq 0 ] && DIMENSION=2
      [ "${SOURCE_FILE}" != "" ] || SOURCE_FILE="${DATA_DIR}/reg10x10.exo"
      [ "${TARGET_FILE}" != "" ] || TARGET_FILE="${DATA_DIR}/polymesh_10x10.exo"
      [ "${ENTITY_KIND}" != "" ] || ENTITY_KIND="cell"
      [ "${MATER_FIELD}" != "" ] || MATER_FIELD="5*x-y,2*x+4+3*y,-2*x-y"
      [ "${MATER_FILE}" != "" ] || MATER_FILE="${DATA_DIR}/reg10x10.bvf"
      [ "${IS_CONFORMAL}" != "" ] || IS_CONFORMAL="y"
      [ "${IS_CONVEX}" != "" ] || IS_CONVEX="y"
      [ "${REMAP_ORDER}" -eq 0 ] && REMAP_ORDER="2"
      [ "${RESULT_FILE}" != "" ] || RESULT_FILE="multimat_jali_unstruc_2d_cell_f1_r2.gmv";;
    timing)
      [ "${DIMENSION}" -eq 0 ] && DIMENSION=2
      [ "${SOURCE_MAX}" -eq 0 ] && SOURCE_MAX=40
      [ "${TARGET_MAX}" -eq 0 ] && TARGET_MAX=120
      [ "${ENTITY_KIND}" != "" ] || ENTITY_KIND="cell"
      [ "${IS_CONFORMAL}" != "" ] || IS_CONFORMAL="y"
      [ "${IS_CONVEX}" != "" ] || IS_CONVEX="y"
      [ "${REVERSE_RANKS}" != "" ] || REVERSE_RANKS="n"
      [ "${WEAK_SCALE_ONLY}" != "" ] || WEAK_SCALE_ONLY="n"
      [ "${REMAP_ORDER}" -eq 0 ] && REMAP_ORDER=1
      [ "${FIELD_ORDER}" -eq 0 ] && FIELD_ORDER=0;;
    (*)
      echo -e "\e[31mError: unsupported ${APP} app\e[0m"
      exit 1;;
  esac
}


setup_run_options() {

  # set build directory  
  BUILD_DIR="${SOURCE_DIR}/build-${COMPILER}"
  
  # slurm partition  
  #CORES=$(grep ^cpu\\scores /proc/cpuinfo | uniq |  awk '{print $4}');
  #LOG_CORES=$(nproc --all);
  #THREADS_PER_CORE=$((LOG_CORES / CORES));;
  
  case "${PARTITION}" in
    scaling) CORES=16; THREADS_PER_CORE=2;;
    skylake-gold) CORES=22; THREADS_PER_CORE=2;;
    (*) 
      echo -e "\e[31mError: invalid slurm partition ${PARTITION}\e[0m"
      exit 1;;
  esac

  # set CPU affinity options
  if [ "${HYPERTHREADING}" = true ]; then
    [ "COMPILER" = "intel" ] && GRAIN="fine" || GRAIN="threads"
  else
    THREADS_PER_CORE=1
    [ "COMPILER" = "intel" ] && GRAIN="core" || GRAIN="cores"
  fi

  # check compiler, set appropriate version and CPU affinity policy
  if [ "${COMPILER}" = "intel" ]; then
    CXX_VERSION=18.0.3
    CPU_AFFINITY="KMP_AFFINITY=granularity=${GRAIN},compact,verbose"
  elif [ "${COMPILER}" = "gcc" ]; then
    CXX_VERSION=6.4.0
    CPU_AFFINITY="OMP_PLACES=${GRAIN} OMP_PROC_BIND=close OMP_DISPLAY_ENV=true"
  fi
  
  MAX_RANKS=$((MAX_NODES * RANKS_PER_NODE))  
  MAX_THREADS=$((CORES * THREADS_PER_CORE))
  
  # run dependent options
  if [ "${OPENMP_ONLY}" = true ]; then
    EXTENT=${MAX_THREADS}
    THREADS="\$i"
    INIT_THREADS=1
    RANKS="1"
    NODES=1
    MODE="threads_omp"
    THREAD_FLAG="y"
  else
    EXTENT=${MAX_NODES}
    THREADS=${MAX_THREADS}
    INIT_THREADS=${THREADS}
    RANKS="\$i"
    NODES=${MAX_NODES}
    MODE="ranks_mpi"
    THREAD_FLAG="n"
  fi
}

update_app_options() {
  APP_ARGS=() 
 
  # set app-specific argument list
  case "${APP}" in
    core)
      APP_ARGS=(
        "./app/portageapp/portageapp_jali"
        "--dim=${DIMENSION}"
        "--source_file=${SOURCE_FILE}"
        "--target_file=${TARGET_SIZE}"
        "--entity_kind=${ENTITY_KIND}"
        "--field=${FIELD}"
        "--remap_order=${REMAP_ORDER}"
        "--results_file=${RESULT_FILE}"
        "--only_threads=${THREAD_FLAG}"
      );;
    t-junction)
      APP_ARGS=(
        "./app/portageapp/portageapp_${APP}_jali"
        "--dim=${DIMENSION}"
        "--nsourcecells=${SOURCE_SIZE}"
        "--ntargetcells=${TARGET_SIZE}"
        "--conformal=${IS_CONFORMAL}"
        "--material_fields=${MATER_FIELD}"
        "--remap_order=${REMAP_ORDER}"
        "--only_threads=${THREAD_FLAG}"
      );;
    multimat)
      APP_ARGS=(
        "./app/portageapp/portageapp_${APP}_jali"
        "--dim=${DIMENSION}"
        "--source_file=${SOURCE_FILE}"
        "--target_file=${TARGET_FILE}"
        "--material_fields=${MATER_FIELD}"
        "--material_file=${MATER_FILE}"
        "--remap_order=${REMAP_ORDER}"
        "--results_file=${RESULT_FILE}"
        "--only_threads=${THREAD_FLAG}"
      );;
    timing)
      APP_ARGS=(
        "./app/${APP}app/${APP}app"
        "--dim=${DIMENSION}"
        "--nsourcecells=${SOURCE_SIZE}"
        "--ntargetcells=${TARGET_SIZE}"
        "--conformal=${IS_CONFORMAL}"
        "--reverse_ranks=${REVERSE_RANKS}"
        "--weak_scale=${WEAK_SCALE_ONLY}"
        "--entity_kind=${ENTITY_KIND}"
        "--field_order=${FIELD_ORDER}"
        "--remap_order=${REMAP_ORDER}"
        "--only_threads=${THREAD_FLAG}"
      );;
    (*)
      echo -e "\e[31mError: invalid or not yet supported app '${APP}'\e[0m"
      exit 1;;
  esac

  # formatting
  MPI_ARGS="--bind-to socket --report-bindings"
  for option in "${APP_ARGS[@]}"; do
    MPI_ARGS+=" \\"$'\n'"\t${option}"
  done
}

setup() {

  # parse options (requires GNU getopt).
  SHORT_OPT="ha:g:n:r:p:u:c:w:d:f:q:s:t:m:z:k:o:ixye:" 
  LONG_OPT="help,app:,cluster:,nodes:,ranks:,partition:,user:,compiler:,hwthreads:,"
  LONG_OPT+="dim:,field:,field-order:,source:,target:,material-field:,material-file:,"
  LONG_OPT+="entity:,order:,conform,convex,thread-only,results:"
  options=""

  # handle no option case
  if [ "$#" -eq 0 ]; then
    echo -e "\e[31mError: please specify the app at least\e[0m"
    exit 1
  elif ! options=$(getopt -o ${SHORT_OPT} -l ${LONG_OPT} -- "$@"); then
    print_usage
  fi
 
  # evaluate the option list 
  eval set -- "${options}"

  REBUILD=false

  # process args
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -h|--help) print_usage;;
      -a|--app) APP="$2"; shift;;
      -g|--cluster) CLUSTER="$2"; shift;;
      -n|--nodes) MAX_NODES="$2"; shift;;
      -r|--ranks) RANKS_PER_NODE="$2"; shift;;
      -p|--partition) PARTITION="$2"; shift;;
      -u|--user) USER="$2"; shift;; 
      -c|--compiler) COMPILER="$2"; shift;;
      -w|--hwthreads) HYPERTHREADING=true;;
      -d|--dim) DIMENSION="$2"; shift;;
      -f|--field) FIELD="$2"; shift;; 
      -q|--field-order) FIELD_ORDER="$2"; shift;; 
      -s|--source) [[ "$2" =~ ^[0-9]+$ ]] && SOURCE_MAX="$2" || SOURCE_FILE="${DATA_DIR}/$2"; shift;;
      -t|--target) [[ "$2" =~ ^[0-9]+$ ]] && TARGET_MAX="$2" || TARGET_FILE="${DATA_DIR}/$2"; shift;;
      -m|--material-field) MATER_FIELD="$2"; shift;; 
      -z|--material-file) MATER_FILE="${DATA_DIR}/$2"; shift;; 
      -k|--entity) ENTITY_KIND="$2"; shift;; 
      -o|--order) REMAP_ORDER="$2"; shift;; 
      -i|--conform) IS_CONFORMAL="y";; 
      -x|--convex) IS_CONVEX="y";; 
      -y|--thread-only) OPENMP_ONLY=true; MAX_NODES=1;; 
      -e|--results) RESULT_FILE="$2"; shift;; 
      --) break;;
      -*) print_usage;;
      *) break;;
    esac
    shift
  done

  # set default params
  set_default_params;
  
  # set benchmark options 
  setup_run_options

  # check all params
  check_params
}

run_scaling() {

  # generate distinct scripts for strong and weak scaling
  for SCALING_TYPE in "${SCALING_RUNS[@]}"; do

    # adjust the problem size on weak scaling
    if [ ${SCALING_TYPE} = "weak" ]; then
      SOURCE_SIZE="\$((i * ${SOURCE_MAX}))" 
      TARGET_SIZE="\$((i * ${TARGET_MAX}))" 
    else
      SOURCE_SIZE="${SOURCE_MAX}" 
      TARGET_SIZE="${TARGET_MAX}" 
    fi
  
    # set app specific args
    update_app_options
    
    # generated files
    OUTPUT="${CLUSTER}_${APP}_${SCALING_TYPE}_scaling_${EXTENT}_${MODE}.log"
    SCRIPT="${CLUSTER}_${APP}_${SCALING_TYPE}_scaling_${EXTENT}_${MODE}.sh"

    echo -e "#!/bin/bash"                                                    > ${SCRIPT}
    echo -e ""                                                              >> ${SCRIPT}
    echo -e "# Batch script for ${APP} ${SCALING_TYPE} scaling app"         >> ${SCRIPT}
    echo -e "# Generated on $(date +'%Y-%m-%d %T')"                         >> ${SCRIPT}
    echo -e ""                                                              >> ${SCRIPT}
    echo -e "#SBATCH --time=2:00:00"                                        >> ${SCRIPT}                      
    echo -e "#SBATCH --partition=${PARTITION}"                              >> ${SCRIPT}                      
    echo -e "#SBATCH --nodes=${NODES}"                                      >> ${SCRIPT} 
    echo -e "#SBATCH --ntasks-per-node=${RANKS_PER_NODE}"                   >> ${SCRIPT}
    echo -e "#SBATCH --job-name=remap"                                      >> ${SCRIPT}
    echo -e "#SBATCH --error=${OUTPUT}"                                     >> ${SCRIPT}
    echo -e "#SBATCH --output=${OUTPUT}"                                    >> ${SCRIPT}
    echo -e "#SBATCH --no-requeue"                                          >> ${SCRIPT} 
    echo -e "#SBATCH --signal=23@60"                                        >> ${SCRIPT}                  
    echo -e ""                                                              >> ${SCRIPT}
    echo -e "# move to the build directory"                                 >> ${SCRIPT}
    echo -e "cd ${BUILD_DIR}"                                               >> ${SCRIPT}
    echo -e ""                                                              >> ${SCRIPT}
    echo -e "# load modules"                                                >> ${SCRIPT}
    echo -e "module load ${COMPILER}/${CXX_VERSION}"                        >> ${SCRIPT}
    echo -e "module load openmpi/${MPI_VERSION}-${COMPILER}_${CXX_VERSION}" >> ${SCRIPT}
    echo -e "module load boost/${BOOST_VERSION}"                            >> ${SCRIPT}
    echo -e ""                                                              >> ${SCRIPT}
    echo -e "# set thread-core affinity"                                    >> ${SCRIPT}
    echo -e "export ${CPU_AFFINITY}"                                        >> ${SCRIPT}
    echo -e ""                                                              >> ${SCRIPT}
    echo -e "# run serial"                                                  >> ${SCRIPT}
    echo -e "export OMP_NUM_THREADS=${INIT_THREADS}"                        >> ${SCRIPT}
    echo -e "mpirun -n 1 ${MPI_ARGS}"                                       >> ${SCRIPT}
    echo -e ""                                                              >> ${SCRIPT}
    echo -e "# run parallel"                                                >> ${SCRIPT}
    echo -e "for ((i=2; i <= ${EXTENT}; i+=2)); do"                         >> ${SCRIPT}
    echo -e "  export OMP_NUM_THREADS=${THREADS}"                           >> ${SCRIPT}
    echo -e "  mpirun -n ${RANKS} ${MPI_ARGS}"                               >> ${SCRIPT}
    echo -e "done"                                                          >> ${SCRIPT}
    echo -e "# ========================================================"    >> ${SCRIPT}

    # Run it
    echo "Running ${APP} ${SCALING_TYPE} scaling"
    sbatch -v ${SCRIPT}
    #cat ${SCRIPT}
  done

  # check slurm allocation
  [ "${USER}" != "" ] && squeue -u ${USER}
}

generate_gnuplot() {
  
  MODE=""
  XMAX=0
  XLABEL=""
  XCOL=0
  SUFFIX=""
  
  if [ "${OPENMP_ONLY}" = true ]; then 
    MODE="OpenMP"
    XMAX=${MAX_THREADS}
    XLABEL="threads"
    XCOL=2
    SUFFIX="omp"
  else
    MODE="MPI+OpenMP"
    XMAX=${MAX_RANKS}
    XLABEL="ranks"
    XCOL=1
    SUFFIX="mpi"
  fi

  FIELDS=(
    "w lp lc rgb '#CB0707' pt 5"
    "w lp lc rgb '#800080' pt 2"
    "w lp lc rgb '#000000' pt 3"
  )
 
  # generate distinct scripts for strong and weak scaling
  for SCALING_TYPE in "${SCALING_RUNS[@]}"; do
    
    INPUT="${CLUSTER}_${APP}_timing_${SUFFIX}.dat"
    OUTPUT="${CLUSTER}_${APP}_${SCALING_TYPE}_scaling_${SUFFIX}.eps"
    SCRIPT="${CLUSTER}_${APP}_${SCALING_TYPE}_scaling_${SUFFIX}.gnu"
  
    echo "# Gnuplot script for ${APP} ${SCALING_TYPE} scaling"         > ${SCRIPT}  
    echo "# Generated on $(date +'%Y-%m-%d %T')"                      >> ${SCRIPT}
    echo ""                                                           >> ${SCRIPT}
    echo "reset"                                                      >> ${SCRIPT}
    echo "set terminal postscript eps enhanced color 14 size 8cm,9cm" >> ${SCRIPT} 
    echo "set output \"${OUTPUT}\""                                   >> ${SCRIPT} 
    echo "set size ratio 1"                                           >> ${SCRIPT} 
    echo "set xlabel \"${XLABEL}\""                                   >> ${SCRIPT} 
    echo "set ylabel \"elapsed (s)\""                                 >> ${SCRIPT} 
    echo "set key below maxcols 1"                                    >> ${SCRIPT} 
    echo ""                                                           >> ${SCRIPT}
    echo "set xrange [1:${XMAX}]"                                     >> ${SCRIPT} 
    echo "set logscale x 2"                                           >> ${SCRIPT} 
    echo "set logscale y 2"                                           >> ${SCRIPT} 
    echo ""                                                           >> ${SCRIPT}
    echo "set title \"${APP} ${MODE} ${SCALING_TYPE} scaling\""       >> ${SCRIPT} 
    echo "set grid"                                                   >> ${SCRIPT}
    echo "plot '${INPUT}' u ${XCOL}:6 t 'remap'     ${FIELDS[0]},\\"  >> ${SCRIPT}
    echo "     '${INPUT}' u ${XCOL}:5 t 'interface' ${FIELDS[1]},\\"  >> ${SCRIPT} 
    echo "     '${INPUT}' u ${XCOL}:7 t 'total'     ${FIELDS[2]}"     >> ${SCRIPT} 
  
    # move to build directory
    mv ${SCRIPT} ${BUILD_DIR}
    echo "Gnuplot script '${SCRIPT}' generated in build directory"
  done
}

# main
setup "$@" && run_scaling && generate_gnuplot
