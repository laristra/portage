A Flexible Conservative Remapping Framework for Exascale Computing

Certik, O., Ferenbaugh, C.R., Garimella, R.V., Herring, A.M., Jean, B.A.,
Malone, C.M. and Sewell, C.M.


We present a conservative remapping framework called Portage that can
transfer fields between general polygonal or polyhedral
meshes.

The transfer (remapping) of computational physics data from one mesh
to another while conserving some integral quantity (such as conserving
total mass while remapping density) over the domain is a critical
component of many simulations. The need for such a remapping may arise
when switching between simulation codes using different meshes, when
switching between two meshes for different physics within the same
simulation. It is also necessary in arbitrary-Lagrangian-Eulerian
simulations when the mesh becomes very distorted and the user or an
automatic algorithm wants to restart the next time step using a
adapted mesh with better quality. The main steps in conservative
remapping are:

1. Search: efficiently finding candidate elements from the source
mesh that may intersect each element of the target mesh.
2. Intersection: finding the intersection or overlap extent of each
element in the target mesh with elements of source mesh
3. Interpolation: computing the field on the target elements by adding
contributions from the source mesh overlaps.

Portage, written in modern C++ (C++ 11 standard), is designed to be a
flexible, extensible and scalable remapping library that can be
deployed in any application that meets some minimum requirements.

Flexibility and extensibility

At the heart of Portage is a templated driver that can be
constructed with any set of classes that can perform the three
required steps, search, intersection and interpolation. Thus, one can
construct a driver that performs searches using bounding boxes,
intersection using exact arithmetic and first-order accurate
interpolation by adding area-weighted contributions from source
elements or one that searches using k-d trees, intersection using
approximations and a first-order accurate interpolation with gradient
limiting to enforce monotonicity. Applications can choose to use some
of the in-built classes for the three steps or furnish their own
customized classes (such as search and intersection classes for
efficient processing of Cartesian meshes).

The Portage driver is also templated on classes for the mesh and state
(field) managers. This means that as long as the application can
construct a mesh and state manager class that can answer a basic set
of queries according to a specified interface, Portage can be
integrated into the application. For linking between two different
codes, the Portage remapping driver can be templated using different
classes for the source and target mesh and state manager.


Scalability:

Finally, Portage has been designed from the start to be scalable in
modern exascale computing environments. Portage can harness the power
of distributed memory and on-node parallelism as long as the
application meets certain interface requirements. Distributed memory
parallelism requires that application mesh and state managers support
the concept of elements owned by a partition and one layer of halo
(ghost) elements around each partition. Enabling on-node parallelism
requires the search, intersection and interpolation classes to be
written in a functional manner which implies that they furnish an
operator that can operate on each element without any side
effects. This allows Portage to use modern parallelization constructs
from NVIDIA's Thrust interface (or the proposed parallel constructs in
C++17) to enable on-node parallelism using OpenMP or Intel TBB
backends. Limited testing has also been done with a CUDA backend.
Preliminary results show excellent on-node scaling up to 64
threads. Tests with distributed memory parallelism are also being
conducted to assess its performance.

We have tested Portage in 2D and 3D for remapping between general
polygonal and polyhedral meshes from two different mesh
frameworks. The version of Portage used for in-house testing employs a
k-d tree search. Intersection of meshes is based on decomposing polygonal
elements into triangles and polyhedral elements into tetrahedra before
intersection using an algorithm developed by Powell
et.al. [1]. Specializations for intersections of Cartesian meshes have
been added for efficiency. The code provides the option of remapping
cell-centered or node-centered variables using 1st or 2nd order
accurate remapping [2]. The 2nd order remapping algorithm uses
Barth-Jesperson limiting of gradients to enforce monotonicity
[3]. Work is underway to add interpolation schemes with higher orders
of accuracy. Also, specializations for Cartesian meshes have been
added to choices available for the code.

Using this flexible, extensible and scalable model, Portage is being
deployed across a number of projects for inline and code-to-code
remapping with many more waiting to adopt it as additional features
such as multi-material remapping come online.

Portage is open source software under the BSD license.


[1] Powell, D. and Abel, T. "An exact general remeshing scheme applied
to physically conservative voxelization," Journal of Computational
Physics, v 297, pp. 340-356, 2015.

[2] Margolin, L. and Shashkov, M.J. "Second-order sign-preserving
conservative interpolation (remapping) on general grids," Journal of
Computational Physics, v 184, n 1, pp. 266-298, 2002.

[3] Barth, T.J. and Jespersen, D.C. "The design and application of
upwind schemes on unstructured meshes," 27th Aerospace Sciences
Meeting, Reno, NV, 1989.
